@document.meta
title: Ltex-utils.nvim: Design and Strategy
description: Design rationale and potential use-cases
authors: Johannes Hofscheier
categories: docs
created: 2023-06-04
updated: 2023-06-29
version: 1.1.1
@end

* TODO
  ~ ( ) implement a `cleanup` function for LTeX that deletes obsolete
		hiddenFalsePositives
  ~ (x) update how dictionaries are written to file. In particular, after
		managing files, we need to be more careful how to write dictionaries.
  ~ ( ) there was one more thing that I wanted to do, but I can't remember
		right now.
* Design considerations
  One buffer can be opened in several windows. In particular, this means that
  changes in one window will apply to the other window too.

  *Another possibility* could be that we cache the server settings in a 'LTeX
  actions' class and whenever a window is opened to modify a rule, we set a
  block (like a *mutex*), so that no further changes can be applied to the
  current LSP server until the rule modification process has been completed.
** Scenario 1
   Suppose the same buffer is open in two windows at the same time. In one
   window the user opens the 'modify rules' window and starts editing a rule.
   They keep the window open and don't save the modified rule yet. They then
   switch to the second window and add/change rules their using (for example)
   code actions). They then get back to the previously open 'modify rule'
   window and want to save it. However, because of the changes they did in the
   other window many issues can arise:
   ~ The rule could be now at another index in the 'rules array'.
   ~ The rule could not exist any more.
   ~ Text might have changed and make the rule obsolete.
** Rule cache
   After careful considerations, it seems most efficient to cache user input
   and then apply all changes to the server and dictionaries after the user has
   finished managing rules. However, this raises the question how to decide
   when the user is done with inspecting, editing, and/or deleting rules. In
   the following, we list a typical workflow and investigate a possibility how
   to determine if cached changes are ready to be applied.
*** Scenario 1
	~ User invokes `:LTeX-utils modify_hiddenFalsePositives`.
	~ User selects an entry and deletes it -> Telescope window stays active, so
	  no `BufEnter` event, and therefore no possible application of cached
      rules. However, we need to set flag that changes are cached to be applied
      later.
	~ User selects entry and wants to modify it -> Telescope window will be
	  closed, so possibility exists that we briefly dip into the source buffer.
	  We need to make sure that we set the flag to apply changes to false.
      After creating the popup window, we can set the flag back to true.
** Implementing a Cleanup Function
   I am able to retrieve diagnostic data for hiddenFalsePositives (that is,
   line numbers and columns, text describing the issue, the rule for the
   server, and kind of issue). This needs to be combined with the server's
   hiddenFalsePositives where I don't have line numbers, text message, and kind
   of issue, but only the rule itself. When I merge these two lists, I want to
   have only one entry for each entry that is contained in both lists, but with
   the record of this entry completed by the data form the other list. If there
   is a rule in the server for which we can't find an entry in the diagnostic
   list, I want the respective entry to be marked as `ERROR` and a text message
   like 'not active in document', and line number/column is left empty/nil. If
   there is a diagnostic entry which doesn't have a respective entry in the
   rule list, then the message is changed to 'not active, but exists'. The
   entries in the two lists have the following form:

   Diagnostic list: {
       bufnr,
	   filename,
	   lnum,
	   col,
	   text,
	   type,
       rule,
   }

   Server list: {
       rule,
   }
	How would I implement this merge function?
** Implementing New Pick Rule Window
   I want to revise how the list of entries is created.
* Conclusions
  ~ actions module should consist only of static functions since one static
	function can deal with all requests. There is no benefit from implementing
	separate code action handlers for each buffer separately.
  ~ when the user is done with modifying a rule, we always need to check if the
	rule still exists in the current settings of the active LTeX LSP server. If
	it is still there, we can override it with the modified one.
  ~~ *Pros*. We make sure that server configuration isn't overridden by obsolete
	 rules or rules are overridden by other rules (e.g., when the index of a
	 rule changes).
  ~~ *Cons*. Because we regularly need to check the server configuration the
	 performance is slower. Caching would be much faster.

